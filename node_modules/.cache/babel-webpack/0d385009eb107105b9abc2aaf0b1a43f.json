{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { EventEmitter, Directive, Input, Output, HostListener, NgModule } from '@angular/core';\nimport { latLng, map, control, tileLayer } from 'leaflet';\n\nclass LeafletUtil {\n  static mapToArray(map) {\n    const toReturn = [];\n\n    for (const k in map) {\n      if (map.hasOwnProperty(k)) {\n        toReturn.push(map[k]);\n      }\n    }\n\n    return toReturn;\n  }\n\n  static handleEvent(zone, eventEmitter, event) {\n    // Don't want to emit if there are no observers\n    if (0 < eventEmitter.observers.length) {\n      zone.run(() => {\n        eventEmitter.emit(event);\n      });\n    }\n  }\n\n}\n\nclass LeafletDirective {\n  constructor(element, zone) {\n    this.element = element;\n    this.zone = zone;\n    this.DEFAULT_ZOOM = 1;\n    this.DEFAULT_CENTER = latLng(38.907192, -77.036871);\n    this.DEFAULT_FPZ_OPTIONS = {};\n    this.fitBoundsOptions = this.DEFAULT_FPZ_OPTIONS;\n    this.panOptions = this.DEFAULT_FPZ_OPTIONS;\n    this.zoomOptions = this.DEFAULT_FPZ_OPTIONS;\n    this.zoomPanOptions = this.DEFAULT_FPZ_OPTIONS; // Default configuration\n\n    this.options = {}; // Configure callback function for the map\n\n    this.mapReady = new EventEmitter();\n    this.zoomChange = new EventEmitter();\n    this.centerChange = new EventEmitter(); // Mouse Map Events\n\n    this.onClick = new EventEmitter();\n    this.onDoubleClick = new EventEmitter();\n    this.onMouseDown = new EventEmitter();\n    this.onMouseUp = new EventEmitter();\n    this.onMouseMove = new EventEmitter();\n    this.onMouseOver = new EventEmitter();\n    this.onMouseOut = new EventEmitter(); // Map Move Events\n\n    this.onMapMove = new EventEmitter();\n    this.onMapMoveStart = new EventEmitter();\n    this.onMapMoveEnd = new EventEmitter(); // Map Zoom Events\n\n    this.onMapZoom = new EventEmitter();\n    this.onMapZoomStart = new EventEmitter();\n    this.onMapZoomEnd = new EventEmitter(); // Nothing here\n  }\n\n  ngOnInit() {\n    // Create the map outside of angular so the various map events don't trigger change detection\n    this.zone.runOutsideAngular(() => {\n      // Create the map with some reasonable defaults\n      this.map = map(this.element.nativeElement, this.options);\n      this.addMapEventListeners();\n    }); // Only setView if there is a center/zoom\n\n    if (null != this.center && null != this.zoom) {\n      this.setView(this.center, this.zoom);\n    } // Set up all the initial settings\n\n\n    if (null != this.fitBounds) {\n      this.setFitBounds(this.fitBounds);\n    }\n\n    if (null != this.maxBounds) {\n      this.setMaxBounds(this.maxBounds);\n    }\n\n    if (null != this.minZoom) {\n      this.setMinZoom(this.minZoom);\n    }\n\n    if (null != this.maxZoom) {\n      this.setMaxZoom(this.maxZoom);\n    }\n\n    this.doResize(); // Fire map ready event\n\n    this.mapReady.emit(this.map);\n  }\n\n  ngOnChanges(changes) {\n    /*\n     * The following code is to address an issue with our (basic) implementation of\n     * zooming and panning. From our testing, it seems that a pan operation followed\n     * by a zoom operation in the same thread will interfere with eachother. The zoom\n     * operation interrupts/cancels the pan, resulting in a final center point that is\n     * inaccurate. The solution seems to be to either separate them with a timeout or\n      * to collapse them into a setView call.\n     */\n    // Zooming and Panning\n    if (changes['zoom'] && changes['center'] && null != this.zoom && null != this.center) {\n      this.setView(changes['center'].currentValue, changes['zoom'].currentValue);\n    } // Set the zoom level\n    else if (changes['zoom']) {\n      this.setZoom(changes['zoom'].currentValue);\n    } // Set the map center\n    else if (changes['center']) {\n      this.setCenter(changes['center'].currentValue);\n    } // Other options\n\n\n    if (changes['fitBounds']) {\n      this.setFitBounds(changes['fitBounds'].currentValue);\n    }\n\n    if (changes['maxBounds']) {\n      this.setMaxBounds(changes['maxBounds'].currentValue);\n    }\n\n    if (changes['minZoom']) {\n      this.setMinZoom(changes['minZoom'].currentValue);\n    }\n\n    if (changes['maxZoom']) {\n      this.setMaxZoom(changes['maxZoom'].currentValue);\n    }\n  }\n\n  ngOnDestroy() {\n    // If this directive is destroyed, the map is too\n    if (null != this.map) {\n      this.map.remove();\n    }\n  }\n\n  getMap() {\n    return this.map;\n  }\n\n  onResize() {\n    this.delayResize();\n  }\n\n  addMapEventListeners() {\n    const registerEventHandler = (eventName, handler) => {\n      this.map.on(eventName, handler);\n    }; // Add all the pass-through mouse event handlers\n\n\n    registerEventHandler('click', e => LeafletUtil.handleEvent(this.zone, this.onClick, e));\n    registerEventHandler('dblclick', e => LeafletUtil.handleEvent(this.zone, this.onDoubleClick, e));\n    registerEventHandler('mousedown', e => LeafletUtil.handleEvent(this.zone, this.onMouseDown, e));\n    registerEventHandler('mouseup', e => LeafletUtil.handleEvent(this.zone, this.onMouseUp, e));\n    registerEventHandler('mouseover', e => LeafletUtil.handleEvent(this.zone, this.onMouseOver, e));\n    registerEventHandler('mouseout', e => LeafletUtil.handleEvent(this.zone, this.onMouseOut, e));\n    registerEventHandler('mousemove', e => LeafletUtil.handleEvent(this.zone, this.onMouseMove, e));\n    registerEventHandler('zoomstart', e => LeafletUtil.handleEvent(this.zone, this.onMapZoomStart, e));\n    registerEventHandler('zoom', e => LeafletUtil.handleEvent(this.zone, this.onMapZoom, e));\n    registerEventHandler('zoomend', e => LeafletUtil.handleEvent(this.zone, this.onMapZoomEnd, e));\n    registerEventHandler('movestart', e => LeafletUtil.handleEvent(this.zone, this.onMapMoveStart, e));\n    registerEventHandler('move', e => LeafletUtil.handleEvent(this.zone, this.onMapMove, e));\n    registerEventHandler('moveend', e => LeafletUtil.handleEvent(this.zone, this.onMapMoveEnd, e)); // Update any things for which we provide output bindings\n\n    const outputUpdateHandler = () => {\n      const zoom = this.map.getZoom();\n\n      if (zoom !== this.zoom) {\n        this.zoom = zoom;\n        LeafletUtil.handleEvent(this.zone, this.zoomChange, zoom);\n      }\n\n      const center = this.map.getCenter();\n\n      if (null != center || null != this.center) {\n        if ((null == center || null == this.center) && center !== this.center || center.lat !== this.center.lat || center.lng !== this.center.lng) {\n          this.center = center;\n          LeafletUtil.handleEvent(this.zone, this.centerChange, center);\n        }\n      }\n    };\n\n    registerEventHandler('moveend', outputUpdateHandler);\n    registerEventHandler('zoomend', outputUpdateHandler);\n  }\n  /**\n   * Resize the map to fit it's parent container\n   */\n\n\n  doResize() {\n    // Run this outside of angular so the map events stay outside of angular\n    this.zone.runOutsideAngular(() => {\n      // Invalidate the map size to trigger it to update itself\n      if (null != this.map) {\n        this.map.invalidateSize({});\n      }\n    });\n  }\n  /**\n   * Manage a delayed resize of the component\n   */\n\n\n  delayResize() {\n    if (null != this.resizeTimer) {\n      clearTimeout(this.resizeTimer);\n    }\n\n    this.resizeTimer = setTimeout(this.doResize.bind(this), 200);\n  }\n  /**\n   * Set the view (center/zoom) all at once\n   * @param center The new center\n   * @param zoom The new zoom level\n   */\n\n\n  setView(center, zoom) {\n    if (null != this.map && null != center && null != zoom) {\n      this.map.setView(center, zoom, this.zoomPanOptions);\n    }\n  }\n  /**\n   * Set the map zoom level\n   * @param zoom the new zoom level for the map\n   */\n\n\n  setZoom(zoom) {\n    if (null != this.map && null != zoom) {\n      this.map.setZoom(zoom, this.zoomOptions);\n    }\n  }\n  /**\n   * Set the center of the map\n   * @param center the center point\n   */\n\n\n  setCenter(center) {\n    if (null != this.map && null != center) {\n      this.map.panTo(center, this.panOptions);\n    }\n  }\n  /**\n   * Fit the map to the bounds\n   * @param latLngBounds the boundary to set\n   */\n\n\n  setFitBounds(latLngBounds) {\n    if (null != this.map && null != latLngBounds) {\n      this.map.fitBounds(latLngBounds, this.fitBoundsOptions);\n    }\n  }\n  /**\n   * Set the map's max bounds\n   * @param latLngBounds the boundary to set\n   */\n\n\n  setMaxBounds(latLngBounds) {\n    if (null != this.map && null != latLngBounds) {\n      this.map.setMaxBounds(latLngBounds);\n    }\n  }\n  /**\n   * Set the map's min zoom\n   * @param number the new min zoom\n   */\n\n\n  setMinZoom(zoom) {\n    if (null != this.map && null != zoom) {\n      this.map.setMinZoom(zoom);\n    }\n  }\n  /**\n   * Set the map's min zoom\n   * @param number the new min zoom\n   */\n\n\n  setMaxZoom(zoom) {\n    if (null != this.map && null != zoom) {\n      this.map.setMaxZoom(zoom);\n    }\n  }\n\n}\n\nLeafletDirective.ɵfac = function LeafletDirective_Factory(t) {\n  return new (t || LeafletDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n};\n\nLeafletDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: LeafletDirective,\n  selectors: [[\"\", \"leaflet\", \"\"]],\n  hostBindings: function LeafletDirective_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵlistener(\"resize\", function LeafletDirective_resize_HostBindingHandler() {\n        return ctx.onResize();\n      }, false, i0.ɵɵresolveWindow);\n    }\n  },\n  inputs: {\n    fitBoundsOptions: [\"leafletFitBoundsOptions\", \"fitBoundsOptions\"],\n    panOptions: [\"leafletPanOptions\", \"panOptions\"],\n    zoomOptions: [\"leafletZoomOptions\", \"zoomOptions\"],\n    zoomPanOptions: [\"leafletZoomPanOptions\", \"zoomPanOptions\"],\n    options: [\"leafletOptions\", \"options\"],\n    zoom: [\"leafletZoom\", \"zoom\"],\n    center: [\"leafletCenter\", \"center\"],\n    fitBounds: [\"leafletFitBounds\", \"fitBounds\"],\n    maxBounds: [\"leafletMaxBounds\", \"maxBounds\"],\n    minZoom: [\"leafletMinZoom\", \"minZoom\"],\n    maxZoom: [\"leafletMaxZoom\", \"maxZoom\"]\n  },\n  outputs: {\n    mapReady: \"leafletMapReady\",\n    zoomChange: \"leafletZoomChange\",\n    centerChange: \"leafletCenterChange\",\n    onClick: \"leafletClick\",\n    onDoubleClick: \"leafletDoubleClick\",\n    onMouseDown: \"leafletMouseDown\",\n    onMouseUp: \"leafletMouseUp\",\n    onMouseMove: \"leafletMouseMove\",\n    onMouseOver: \"leafletMouseOver\",\n    onMouseOut: \"leafletMouseOut\",\n    onMapMove: \"leafletMapMove\",\n    onMapMoveStart: \"leafletMapMoveStart\",\n    onMapMoveEnd: \"leafletMapMoveEnd\",\n    onMapZoom: \"leafletMapZoom\",\n    onMapZoomStart: \"leafletMapZoomStart\",\n    onMapZoomEnd: \"leafletMapZoomEnd\"\n  },\n  features: [i0.ɵɵNgOnChangesFeature]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LeafletDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[leaflet]'\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }, {\n      type: i0.NgZone\n    }];\n  }, {\n    fitBoundsOptions: [{\n      type: Input,\n      args: ['leafletFitBoundsOptions']\n    }],\n    panOptions: [{\n      type: Input,\n      args: ['leafletPanOptions']\n    }],\n    zoomOptions: [{\n      type: Input,\n      args: ['leafletZoomOptions']\n    }],\n    zoomPanOptions: [{\n      type: Input,\n      args: ['leafletZoomPanOptions']\n    }],\n    options: [{\n      type: Input,\n      args: ['leafletOptions']\n    }],\n    mapReady: [{\n      type: Output,\n      args: ['leafletMapReady']\n    }],\n    zoom: [{\n      type: Input,\n      args: ['leafletZoom']\n    }],\n    zoomChange: [{\n      type: Output,\n      args: ['leafletZoomChange']\n    }],\n    center: [{\n      type: Input,\n      args: ['leafletCenter']\n    }],\n    centerChange: [{\n      type: Output,\n      args: ['leafletCenterChange']\n    }],\n    fitBounds: [{\n      type: Input,\n      args: ['leafletFitBounds']\n    }],\n    maxBounds: [{\n      type: Input,\n      args: ['leafletMaxBounds']\n    }],\n    minZoom: [{\n      type: Input,\n      args: ['leafletMinZoom']\n    }],\n    maxZoom: [{\n      type: Input,\n      args: ['leafletMaxZoom']\n    }],\n    onClick: [{\n      type: Output,\n      args: ['leafletClick']\n    }],\n    onDoubleClick: [{\n      type: Output,\n      args: ['leafletDoubleClick']\n    }],\n    onMouseDown: [{\n      type: Output,\n      args: ['leafletMouseDown']\n    }],\n    onMouseUp: [{\n      type: Output,\n      args: ['leafletMouseUp']\n    }],\n    onMouseMove: [{\n      type: Output,\n      args: ['leafletMouseMove']\n    }],\n    onMouseOver: [{\n      type: Output,\n      args: ['leafletMouseOver']\n    }],\n    onMouseOut: [{\n      type: Output,\n      args: ['leafletMouseOut']\n    }],\n    onMapMove: [{\n      type: Output,\n      args: ['leafletMapMove']\n    }],\n    onMapMoveStart: [{\n      type: Output,\n      args: ['leafletMapMoveStart']\n    }],\n    onMapMoveEnd: [{\n      type: Output,\n      args: ['leafletMapMoveEnd']\n    }],\n    onMapZoom: [{\n      type: Output,\n      args: ['leafletMapZoom']\n    }],\n    onMapZoomStart: [{\n      type: Output,\n      args: ['leafletMapZoomStart']\n    }],\n    onMapZoomEnd: [{\n      type: Output,\n      args: ['leafletMapZoomEnd']\n    }],\n    onResize: [{\n      type: HostListener,\n      args: ['window:resize', []]\n    }]\n  });\n})();\n\nclass LeafletDirectiveWrapper {\n  constructor(leafletDirective) {\n    this.leafletDirective = leafletDirective;\n  }\n\n  init() {// Nothing for now\n  }\n\n  getMap() {\n    return this.leafletDirective.getMap();\n  }\n\n}\n/**\n * Layer directive\n *\n * This directive is used to directly control a single map layer. The purpose of this directive is to\n * be used as part of a child structural directive of the map element.\n *\n */\n\n\nclass LeafletLayerDirective {\n  constructor(leafletDirective, zone) {\n    this.zone = zone; // Layer Events\n\n    this.onAdd = new EventEmitter();\n    this.onRemove = new EventEmitter();\n    this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n  }\n\n  ngOnInit() {\n    // Init the map\n    this.leafletDirective.init();\n  }\n\n  ngOnDestroy() {\n    if (null != this.layer) {\n      // Unregister the event handlers\n      this.removeLayerEventListeners(this.layer); // Remove the layer from the map\n\n      this.layer.remove();\n    }\n  }\n\n  ngOnChanges(changes) {\n    if (changes['layer']) {\n      // Update the layer\n      const p = changes['layer'].previousValue;\n      const n = changes['layer'].currentValue;\n      this.zone.runOutsideAngular(() => {\n        if (null != p) {\n          this.removeLayerEventListeners(p);\n          p.remove();\n        }\n\n        if (null != n) {\n          this.addLayerEventListeners(n);\n          this.leafletDirective.getMap().addLayer(n);\n        }\n      });\n    }\n  }\n\n  addLayerEventListeners(l) {\n    this.onAddLayerHandler = e => LeafletUtil.handleEvent(this.zone, this.onAdd, e);\n\n    l.on('add', this.onAddLayerHandler);\n\n    this.onRemoveLayerHandler = e => LeafletUtil.handleEvent(this.zone, this.onRemove, e);\n\n    l.on('remove', this.onRemoveLayerHandler);\n  }\n\n  removeLayerEventListeners(l) {\n    l.off('add', this.onAddLayerHandler);\n    l.off('remove', this.onRemoveLayerHandler);\n  }\n\n}\n\nLeafletLayerDirective.ɵfac = function LeafletLayerDirective_Factory(t) {\n  return new (t || LeafletLayerDirective)(i0.ɵɵdirectiveInject(LeafletDirective), i0.ɵɵdirectiveInject(i0.NgZone));\n};\n\nLeafletLayerDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: LeafletLayerDirective,\n  selectors: [[\"\", \"leafletLayer\", \"\"]],\n  inputs: {\n    layer: [\"leafletLayer\", \"layer\"]\n  },\n  outputs: {\n    onAdd: \"leafletLayerAdd\",\n    onRemove: \"leafletLayerRemove\"\n  },\n  features: [i0.ɵɵNgOnChangesFeature]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LeafletLayerDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[leafletLayer]'\n    }]\n  }], function () {\n    return [{\n      type: LeafletDirective\n    }, {\n      type: i0.NgZone\n    }];\n  }, {\n    layer: [{\n      type: Input,\n      args: ['leafletLayer']\n    }],\n    onAdd: [{\n      type: Output,\n      args: ['leafletLayerAdd']\n    }],\n    onRemove: [{\n      type: Output,\n      args: ['leafletLayerRemove']\n    }]\n  });\n})();\n/**\n * Layers directive\n *\n * This directive is used to directly control map layers. As changes are made to the input array of\n * layers, the map is synched to the array. As layers are added or removed from the input array, they\n * are also added or removed from the map. The input array is treated as immutable. To detect changes,\n * you must change the array instance.\n *\n * Important Note: The input layers array is assumed to be immutable. This means you need to use an\n * immutable array implementation or create a new copy of your array when you make changes, otherwise\n * this directive won't detect the change. This is by design. It's for performance reasons. Change\n * detection of mutable arrays requires diffing the state of the array on every DoCheck cycle, which\n * is extremely expensive from a time complexity perspective.\n *\n */\n\n\nclass LeafletLayersDirective {\n  constructor(leafletDirective, differs, zone) {\n    this.differs = differs;\n    this.zone = zone;\n    this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n    this.layersDiffer = this.differs.find([]).create();\n  } // Set/get the layers\n\n\n  set layers(v) {\n    this.layersValue = v; // Now that we have a differ, do an immediate layer update\n\n    this.updateLayers();\n  }\n\n  get layers() {\n    return this.layersValue;\n  }\n\n  ngDoCheck() {\n    this.updateLayers();\n  }\n\n  ngOnInit() {\n    // Init the map\n    this.leafletDirective.init(); // Update layers once the map is ready\n\n    this.updateLayers();\n  }\n\n  ngOnDestroy() {\n    this.layers = [];\n  }\n  /**\n   * Update the state of the layers.\n   * We use an iterable differ to synchronize the map layers with the state of the bound layers array.\n   * This is important because it allows us to react to changes to the contents of the array as well\n   * as changes to the actual array instance.\n   */\n\n\n  updateLayers() {\n    const map = this.leafletDirective.getMap();\n\n    if (null != map && null != this.layersDiffer) {\n      const changes = this.layersDiffer.diff(this.layersValue);\n\n      if (null != changes) {\n        // Run outside angular to ensure layer events don't trigger change detection\n        this.zone.runOutsideAngular(() => {\n          changes.forEachRemovedItem(c => {\n            map.removeLayer(c.item);\n          });\n          changes.forEachAddedItem(c => {\n            map.addLayer(c.item);\n          });\n        });\n      }\n    }\n  }\n\n}\n\nLeafletLayersDirective.ɵfac = function LeafletLayersDirective_Factory(t) {\n  return new (t || LeafletLayersDirective)(i0.ɵɵdirectiveInject(LeafletDirective), i0.ɵɵdirectiveInject(i0.IterableDiffers), i0.ɵɵdirectiveInject(i0.NgZone));\n};\n\nLeafletLayersDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: LeafletLayersDirective,\n  selectors: [[\"\", \"leafletLayers\", \"\"]],\n  inputs: {\n    layers: [\"leafletLayers\", \"layers\"]\n  }\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LeafletLayersDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[leafletLayers]'\n    }]\n  }], function () {\n    return [{\n      type: LeafletDirective\n    }, {\n      type: i0.IterableDiffers\n    }, {\n      type: i0.NgZone\n    }];\n  }, {\n    layers: [{\n      type: Input,\n      args: ['leafletLayers']\n    }]\n  });\n})();\n\nclass LeafletControlLayersChanges {\n  constructor() {\n    this.layersRemoved = 0;\n    this.layersChanged = 0;\n    this.layersAdded = 0;\n  }\n\n  changed() {\n    return !(this.layersRemoved === 0 && this.layersChanged === 0 && this.layersAdded === 0);\n  }\n\n}\n\nclass LeafletControlLayersWrapper {\n  constructor(zone, layersControlReady) {\n    this.zone = zone;\n    this.layersControlReady = layersControlReady;\n  }\n\n  getLayersControl() {\n    return this.layersControl;\n  }\n\n  init(controlConfig, controlOptions) {\n    const baseLayers = controlConfig.baseLayers || {};\n    const overlays = controlConfig.overlays || {}; // Create the control outside of angular to ensure events don't trigger change detection\n\n    this.zone.runOutsideAngular(() => {\n      this.layersControl = control.layers(baseLayers, overlays, controlOptions);\n    });\n    this.layersControlReady.emit(this.layersControl);\n    return this.layersControl;\n  }\n\n  applyBaseLayerChanges(changes) {\n    let results = new LeafletControlLayersChanges();\n\n    if (null != this.layersControl) {\n      results = this.applyChanges(changes, this.layersControl.addBaseLayer);\n    }\n\n    return results;\n  }\n\n  applyOverlayChanges(changes) {\n    let results = new LeafletControlLayersChanges();\n\n    if (null != this.layersControl) {\n      results = this.applyChanges(changes, this.layersControl.addOverlay);\n    }\n\n    return results;\n  }\n\n  applyChanges(changes, addFn) {\n    const results = new LeafletControlLayersChanges();\n\n    if (null != changes) {\n      // All layer management is outside angular to avoid layer events from triggering change detection\n      this.zone.runOutsideAngular(() => {\n        changes.forEachChangedItem(c => {\n          this.layersControl.removeLayer(c.previousValue);\n          addFn.call(this.layersControl, c.currentValue, c.key);\n          results.layersChanged++;\n        });\n        changes.forEachRemovedItem(c => {\n          this.layersControl.removeLayer(c.previousValue);\n          results.layersRemoved++;\n        });\n        changes.forEachAddedItem(c => {\n          addFn.call(this.layersControl, c.currentValue, c.key);\n          results.layersAdded++;\n        });\n      });\n    }\n\n    return results;\n  }\n\n}\n\nclass LeafletControlLayersConfig {\n  constructor() {\n    this.baseLayers = {};\n    this.overlays = {};\n  }\n\n}\n/**\n * Layers Control\n *\n * This directive is used to configure the layers control. The input accepts an object with two\n * key-value maps of layer name -> layer. Mutable changes are detected. On changes, a differ is\n * used to determine what changed so that layers are appropriately added or removed.\n *\n * To specify which layer to show as the 'active' baselayer, you will want to add it to the map\n * using the layers directive. Otherwise, the last one it sees will be used.\n */\n\n\nclass LeafletLayersControlDirective {\n  constructor(leafletDirective, differs, zone) {\n    this.differs = differs;\n    this.zone = zone;\n    this.layersControlReady = new EventEmitter();\n    this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n    this.controlLayers = new LeafletControlLayersWrapper(this.zone, this.layersControlReady); // Generate differs\n\n    this.baseLayersDiffer = this.differs.find({}).create();\n    this.overlaysDiffer = this.differs.find({}).create();\n  }\n\n  set layersControlConfig(v) {\n    // Validation/init stuff\n    if (null == v) {\n      v = new LeafletControlLayersConfig();\n    }\n\n    if (null == v.baseLayers) {\n      v.baseLayers = {};\n    }\n\n    if (null == v.overlays) {\n      v.overlays = {};\n    } // Store the value\n\n\n    this.layersControlConfigValue = v; // Update the map\n\n    this.updateLayers();\n  }\n\n  get layersControlConfig() {\n    return this.layersControlConfigValue;\n  }\n\n  ngOnInit() {\n    // Init the map\n    this.leafletDirective.init(); // Set up control outside of angular to avoid change detection when using the control\n\n    this.zone.runOutsideAngular(() => {\n      // Set up all the initial settings\n      this.controlLayers.init({}, this.layersControlOptions).addTo(this.leafletDirective.getMap());\n    });\n    this.updateLayers();\n  }\n\n  ngOnDestroy() {\n    this.layersControlConfig = {\n      baseLayers: {},\n      overlays: {}\n    };\n    this.controlLayers.getLayersControl().remove();\n  }\n\n  ngDoCheck() {\n    this.updateLayers();\n  }\n\n  updateLayers() {\n    const map = this.leafletDirective.getMap();\n    const layersControl = this.controlLayers.getLayersControl();\n\n    if (null != map && null != layersControl) {\n      // Run the baselayers differ\n      if (null != this.baseLayersDiffer && null != this.layersControlConfigValue.baseLayers) {\n        const changes = this.baseLayersDiffer.diff(this.layersControlConfigValue.baseLayers);\n        this.controlLayers.applyBaseLayerChanges(changes);\n      } // Run the overlays differ\n\n\n      if (null != this.overlaysDiffer && null != this.layersControlConfigValue.overlays) {\n        const changes = this.overlaysDiffer.diff(this.layersControlConfigValue.overlays);\n        this.controlLayers.applyOverlayChanges(changes);\n      }\n    }\n  }\n\n}\n\nLeafletLayersControlDirective.ɵfac = function LeafletLayersControlDirective_Factory(t) {\n  return new (t || LeafletLayersControlDirective)(i0.ɵɵdirectiveInject(LeafletDirective), i0.ɵɵdirectiveInject(i0.KeyValueDiffers), i0.ɵɵdirectiveInject(i0.NgZone));\n};\n\nLeafletLayersControlDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: LeafletLayersControlDirective,\n  selectors: [[\"\", \"leafletLayersControl\", \"\"]],\n  inputs: {\n    layersControlConfig: [\"leafletLayersControl\", \"layersControlConfig\"],\n    layersControlOptions: [\"leafletLayersControlOptions\", \"layersControlOptions\"]\n  },\n  outputs: {\n    layersControlReady: \"leafletLayersControlReady\"\n  }\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LeafletLayersControlDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[leafletLayersControl]'\n    }]\n  }], function () {\n    return [{\n      type: LeafletDirective\n    }, {\n      type: i0.KeyValueDiffers\n    }, {\n      type: i0.NgZone\n    }];\n  }, {\n    layersControlConfig: [{\n      type: Input,\n      args: ['leafletLayersControl']\n    }],\n    layersControlOptions: [{\n      type: Input,\n      args: ['leafletLayersControlOptions']\n    }],\n    layersControlReady: [{\n      type: Output,\n      args: ['leafletLayersControlReady']\n    }]\n  });\n})();\n/**\n * Baselayers directive\n *\n * This directive is provided as a convenient way to add baselayers to the map. The input accepts\n * a key-value map of layer name -> layer. Mutable changed are detected. On changes, a differ is\n * used to determine what changed so that layers are appropriately added or removed. This directive\n * will also add the layers control so users can switch between available base layers.\n *\n * To specify which layer to show as the 'active' baselayer, you will want to add it to the map\n * using the layers directive. Otherwise, the plugin will use the last one it sees.\n */\n\n\nclass LeafletBaseLayersDirective {\n  constructor(leafletDirective, differs, zone) {\n    this.differs = differs;\n    this.zone = zone; // Output for once the layers control is ready\n\n    this.layersControlReady = new EventEmitter();\n    this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n    this.controlLayers = new LeafletControlLayersWrapper(this.zone, this.layersControlReady);\n    this.baseLayersDiffer = this.differs.find({}).create();\n  } // Set/get baseLayers\n\n\n  set baseLayers(v) {\n    this.baseLayersValue = v;\n    this.updateBaseLayers();\n  }\n\n  get baseLayers() {\n    return this.baseLayersValue;\n  }\n\n  ngOnDestroy() {\n    this.baseLayers = {};\n\n    if (null != this.controlLayers.getLayersControl()) {\n      this.controlLayers.getLayersControl().remove();\n    }\n  }\n\n  ngOnInit() {\n    // Init the map\n    this.leafletDirective.init(); // Create the control outside angular to prevent events from triggering chnage detection\n\n    this.zone.runOutsideAngular(() => {\n      // Initially configure the controlLayers\n      this.controlLayers.init({}, this.layersControlOptions).addTo(this.leafletDirective.getMap());\n    });\n    this.updateBaseLayers();\n  }\n\n  ngDoCheck() {\n    this.updateBaseLayers();\n  }\n\n  updateBaseLayers() {\n    const map = this.leafletDirective.getMap();\n    const layersControl = this.controlLayers.getLayersControl();\n\n    if (null != map && null != layersControl && null != this.baseLayersDiffer) {\n      const changes = this.baseLayersDiffer.diff(this.baseLayersValue);\n      const results = this.controlLayers.applyBaseLayerChanges(changes);\n\n      if (results.changed()) {\n        this.syncBaseLayer();\n      }\n    }\n  }\n  /**\n   * Check the current base layer and change it to the new one if necessary\n   */\n\n\n  syncBaseLayer() {\n    const map = this.leafletDirective.getMap();\n    const layers = LeafletUtil.mapToArray(this.baseLayers);\n    let foundLayer; // Search all the layers in the map to see if we can find them in the baselayer array\n\n    map.eachLayer(l => {\n      foundLayer = layers.find(bl => l === bl);\n    }); // Did we find the layer?\n\n    if (null != foundLayer) {\n      // Yes - set the baselayer to the one we found\n      this.baseLayer = foundLayer;\n    } else {\n      // No - set the baselayer to the first in the array and add it to the map\n      if (layers.length > 0) {\n        this.baseLayer = layers[0]; // Add layers outside of angular to prevent events from triggering change detection\n\n        this.zone.runOutsideAngular(() => {\n          this.baseLayer.addTo(map);\n        });\n      }\n    }\n  }\n\n}\n\nLeafletBaseLayersDirective.ɵfac = function LeafletBaseLayersDirective_Factory(t) {\n  return new (t || LeafletBaseLayersDirective)(i0.ɵɵdirectiveInject(LeafletDirective), i0.ɵɵdirectiveInject(i0.KeyValueDiffers), i0.ɵɵdirectiveInject(i0.NgZone));\n};\n\nLeafletBaseLayersDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: LeafletBaseLayersDirective,\n  selectors: [[\"\", \"leafletBaseLayers\", \"\"]],\n  inputs: {\n    baseLayers: [\"leafletBaseLayers\", \"baseLayers\"],\n    layersControlOptions: [\"leafletLayersControlOptions\", \"layersControlOptions\"]\n  },\n  outputs: {\n    layersControlReady: \"leafletLayersControlReady\"\n  }\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LeafletBaseLayersDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[leafletBaseLayers]'\n    }]\n  }], function () {\n    return [{\n      type: LeafletDirective\n    }, {\n      type: i0.KeyValueDiffers\n    }, {\n      type: i0.NgZone\n    }];\n  }, {\n    baseLayers: [{\n      type: Input,\n      args: ['leafletBaseLayers']\n    }],\n    layersControlOptions: [{\n      type: Input,\n      args: ['leafletLayersControlOptions']\n    }],\n    layersControlReady: [{\n      type: Output,\n      args: ['leafletLayersControlReady']\n    }]\n  });\n})();\n\nclass LeafletModule {}\n\nLeafletModule.ɵfac = function LeafletModule_Factory(t) {\n  return new (t || LeafletModule)();\n};\n\nLeafletModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: LeafletModule\n});\nLeafletModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LeafletModule, [{\n    type: NgModule,\n    args: [{\n      exports: [LeafletDirective, LeafletLayerDirective, LeafletLayersDirective, LeafletLayersControlDirective, LeafletBaseLayersDirective],\n      declarations: [LeafletDirective, LeafletLayerDirective, LeafletLayersDirective, LeafletLayersControlDirective, LeafletBaseLayersDirective]\n    }]\n  }], null, null);\n})();\n\nclass LeafletTileLayerDefinition {\n  constructor(type, url, options) {\n    this.type = type;\n    this.url = url;\n    this.options = options;\n  }\n  /**\n   * Creates a TileLayer from the provided definition. This is a convenience function\n   * to help with generating layers from objects.\n   *\n   * @param layerDef The layer to create\n   * @returns {TileLayer} The TileLayer that has been created\n   */\n\n\n  static createTileLayer(layerDef) {\n    let layer;\n\n    switch (layerDef.type) {\n      case 'xyz':\n        layer = tileLayer(layerDef.url, layerDef.options);\n        break;\n\n      case 'wms':\n      default:\n        layer = tileLayer.wms(layerDef.url, layerDef.options);\n        break;\n    }\n\n    return layer;\n  }\n  /**\n   * Creates a TileLayer for each key in the incoming map. This is a convenience function\n   * for generating an associative array of layers from an associative array of objects\n   *\n   * @param layerDefs A map of key to tile layer definition\n   * @returns {{[p: string]: TileLayer}} A new map of key to TileLayer\n   */\n\n\n  static createTileLayers(layerDefs) {\n    const layers = {};\n\n    for (const k in layerDefs) {\n      if (layerDefs.hasOwnProperty(k)) {\n        layers[k] = LeafletTileLayerDefinition.createTileLayer(layerDefs[k]);\n      }\n    }\n\n    return layers;\n  }\n  /**\n   * Create a Tile Layer from the current state of this object\n   *\n   * @returns {TileLayer} A new TileLayer\n   */\n\n\n  createTileLayer() {\n    return LeafletTileLayerDefinition.createTileLayer(this);\n  }\n\n}\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { LeafletBaseLayersDirective, LeafletControlLayersChanges, LeafletControlLayersConfig, LeafletControlLayersWrapper, LeafletDirective, LeafletDirectiveWrapper, LeafletLayerDirective, LeafletLayersControlDirective, LeafletLayersDirective, LeafletModule, LeafletTileLayerDefinition, LeafletUtil };","map":{"version":3,"sources":["E:/web/angular .net core curso/Proyecto/angular/front-end/node_modules/@asymmetrik/ngx-leaflet/fesm2015/asymmetrik-ngx-leaflet.mjs"],"names":["i0","EventEmitter","Directive","Input","Output","HostListener","NgModule","latLng","map","control","tileLayer","LeafletUtil","mapToArray","toReturn","k","hasOwnProperty","push","handleEvent","zone","eventEmitter","event","observers","length","run","emit","LeafletDirective","constructor","element","DEFAULT_ZOOM","DEFAULT_CENTER","DEFAULT_FPZ_OPTIONS","fitBoundsOptions","panOptions","zoomOptions","zoomPanOptions","options","mapReady","zoomChange","centerChange","onClick","onDoubleClick","onMouseDown","onMouseUp","onMouseMove","onMouseOver","onMouseOut","onMapMove","onMapMoveStart","onMapMoveEnd","onMapZoom","onMapZoomStart","onMapZoomEnd","ngOnInit","runOutsideAngular","nativeElement","addMapEventListeners","center","zoom","setView","fitBounds","setFitBounds","maxBounds","setMaxBounds","minZoom","setMinZoom","maxZoom","setMaxZoom","doResize","ngOnChanges","changes","currentValue","setZoom","setCenter","ngOnDestroy","remove","getMap","onResize","delayResize","registerEventHandler","eventName","handler","on","e","outputUpdateHandler","getZoom","getCenter","lat","lng","invalidateSize","resizeTimer","clearTimeout","setTimeout","bind","panTo","latLngBounds","ɵfac","ElementRef","NgZone","ɵdir","type","args","selector","LeafletDirectiveWrapper","leafletDirective","init","LeafletLayerDirective","onAdd","onRemove","layer","removeLayerEventListeners","p","previousValue","n","addLayerEventListeners","addLayer","l","onAddLayerHandler","onRemoveLayerHandler","off","LeafletLayersDirective","differs","layersDiffer","find","create","layers","v","layersValue","updateLayers","ngDoCheck","diff","forEachRemovedItem","c","removeLayer","item","forEachAddedItem","IterableDiffers","LeafletControlLayersChanges","layersRemoved","layersChanged","layersAdded","changed","LeafletControlLayersWrapper","layersControlReady","getLayersControl","layersControl","controlConfig","controlOptions","baseLayers","overlays","applyBaseLayerChanges","results","applyChanges","addBaseLayer","applyOverlayChanges","addOverlay","addFn","forEachChangedItem","call","key","LeafletControlLayersConfig","LeafletLayersControlDirective","controlLayers","baseLayersDiffer","overlaysDiffer","layersControlConfig","layersControlConfigValue","layersControlOptions","addTo","KeyValueDiffers","LeafletBaseLayersDirective","baseLayersValue","updateBaseLayers","syncBaseLayer","foundLayer","eachLayer","bl","baseLayer","LeafletModule","ɵmod","ɵinj","exports","declarations","LeafletTileLayerDefinition","url","createTileLayer","layerDef","wms","createTileLayers","layerDefs"],"mappings":"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","sourcesContent":["import * as i0 from '@angular/core';\nimport { EventEmitter, Directive, Input, Output, HostListener, NgModule } from '@angular/core';\nimport { latLng, map, control, tileLayer } from 'leaflet';\n\nclass LeafletUtil {\n    static mapToArray(map) {\n        const toReturn = [];\n        for (const k in map) {\n            if (map.hasOwnProperty(k)) {\n                toReturn.push(map[k]);\n            }\n        }\n        return toReturn;\n    }\n    static handleEvent(zone, eventEmitter, event) {\n        // Don't want to emit if there are no observers\n        if (0 < eventEmitter.observers.length) {\n            zone.run(() => {\n                eventEmitter.emit(event);\n            });\n        }\n    }\n}\n\nclass LeafletDirective {\n    constructor(element, zone) {\n        this.element = element;\n        this.zone = zone;\n        this.DEFAULT_ZOOM = 1;\n        this.DEFAULT_CENTER = latLng(38.907192, -77.036871);\n        this.DEFAULT_FPZ_OPTIONS = {};\n        this.fitBoundsOptions = this.DEFAULT_FPZ_OPTIONS;\n        this.panOptions = this.DEFAULT_FPZ_OPTIONS;\n        this.zoomOptions = this.DEFAULT_FPZ_OPTIONS;\n        this.zoomPanOptions = this.DEFAULT_FPZ_OPTIONS;\n        // Default configuration\n        this.options = {};\n        // Configure callback function for the map\n        this.mapReady = new EventEmitter();\n        this.zoomChange = new EventEmitter();\n        this.centerChange = new EventEmitter();\n        // Mouse Map Events\n        this.onClick = new EventEmitter();\n        this.onDoubleClick = new EventEmitter();\n        this.onMouseDown = new EventEmitter();\n        this.onMouseUp = new EventEmitter();\n        this.onMouseMove = new EventEmitter();\n        this.onMouseOver = new EventEmitter();\n        this.onMouseOut = new EventEmitter();\n        // Map Move Events\n        this.onMapMove = new EventEmitter();\n        this.onMapMoveStart = new EventEmitter();\n        this.onMapMoveEnd = new EventEmitter();\n        // Map Zoom Events\n        this.onMapZoom = new EventEmitter();\n        this.onMapZoomStart = new EventEmitter();\n        this.onMapZoomEnd = new EventEmitter();\n        // Nothing here\n    }\n    ngOnInit() {\n        // Create the map outside of angular so the various map events don't trigger change detection\n        this.zone.runOutsideAngular(() => {\n            // Create the map with some reasonable defaults\n            this.map = map(this.element.nativeElement, this.options);\n            this.addMapEventListeners();\n        });\n        // Only setView if there is a center/zoom\n        if (null != this.center && null != this.zoom) {\n            this.setView(this.center, this.zoom);\n        }\n        // Set up all the initial settings\n        if (null != this.fitBounds) {\n            this.setFitBounds(this.fitBounds);\n        }\n        if (null != this.maxBounds) {\n            this.setMaxBounds(this.maxBounds);\n        }\n        if (null != this.minZoom) {\n            this.setMinZoom(this.minZoom);\n        }\n        if (null != this.maxZoom) {\n            this.setMaxZoom(this.maxZoom);\n        }\n        this.doResize();\n        // Fire map ready event\n        this.mapReady.emit(this.map);\n    }\n    ngOnChanges(changes) {\n        /*\n         * The following code is to address an issue with our (basic) implementation of\n         * zooming and panning. From our testing, it seems that a pan operation followed\n         * by a zoom operation in the same thread will interfere with eachother. The zoom\n         * operation interrupts/cancels the pan, resulting in a final center point that is\n         * inaccurate. The solution seems to be to either separate them with a timeout or\n          * to collapse them into a setView call.\n         */\n        // Zooming and Panning\n        if (changes['zoom'] && changes['center'] && null != this.zoom && null != this.center) {\n            this.setView(changes['center'].currentValue, changes['zoom'].currentValue);\n        }\n        // Set the zoom level\n        else if (changes['zoom']) {\n            this.setZoom(changes['zoom'].currentValue);\n        }\n        // Set the map center\n        else if (changes['center']) {\n            this.setCenter(changes['center'].currentValue);\n        }\n        // Other options\n        if (changes['fitBounds']) {\n            this.setFitBounds(changes['fitBounds'].currentValue);\n        }\n        if (changes['maxBounds']) {\n            this.setMaxBounds(changes['maxBounds'].currentValue);\n        }\n        if (changes['minZoom']) {\n            this.setMinZoom(changes['minZoom'].currentValue);\n        }\n        if (changes['maxZoom']) {\n            this.setMaxZoom(changes['maxZoom'].currentValue);\n        }\n    }\n    ngOnDestroy() {\n        // If this directive is destroyed, the map is too\n        if (null != this.map) {\n            this.map.remove();\n        }\n    }\n    getMap() {\n        return this.map;\n    }\n    onResize() {\n        this.delayResize();\n    }\n    addMapEventListeners() {\n        const registerEventHandler = (eventName, handler) => {\n            this.map.on(eventName, handler);\n        };\n        // Add all the pass-through mouse event handlers\n        registerEventHandler('click', (e) => LeafletUtil.handleEvent(this.zone, this.onClick, e));\n        registerEventHandler('dblclick', (e) => LeafletUtil.handleEvent(this.zone, this.onDoubleClick, e));\n        registerEventHandler('mousedown', (e) => LeafletUtil.handleEvent(this.zone, this.onMouseDown, e));\n        registerEventHandler('mouseup', (e) => LeafletUtil.handleEvent(this.zone, this.onMouseUp, e));\n        registerEventHandler('mouseover', (e) => LeafletUtil.handleEvent(this.zone, this.onMouseOver, e));\n        registerEventHandler('mouseout', (e) => LeafletUtil.handleEvent(this.zone, this.onMouseOut, e));\n        registerEventHandler('mousemove', (e) => LeafletUtil.handleEvent(this.zone, this.onMouseMove, e));\n        registerEventHandler('zoomstart', (e) => LeafletUtil.handleEvent(this.zone, this.onMapZoomStart, e));\n        registerEventHandler('zoom', (e) => LeafletUtil.handleEvent(this.zone, this.onMapZoom, e));\n        registerEventHandler('zoomend', (e) => LeafletUtil.handleEvent(this.zone, this.onMapZoomEnd, e));\n        registerEventHandler('movestart', (e) => LeafletUtil.handleEvent(this.zone, this.onMapMoveStart, e));\n        registerEventHandler('move', (e) => LeafletUtil.handleEvent(this.zone, this.onMapMove, e));\n        registerEventHandler('moveend', (e) => LeafletUtil.handleEvent(this.zone, this.onMapMoveEnd, e));\n        // Update any things for which we provide output bindings\n        const outputUpdateHandler = () => {\n            const zoom = this.map.getZoom();\n            if (zoom !== this.zoom) {\n                this.zoom = zoom;\n                LeafletUtil.handleEvent(this.zone, this.zoomChange, zoom);\n            }\n            const center = this.map.getCenter();\n            if (null != center || null != this.center) {\n                if (((null == center || null == this.center) && center !== this.center)\n                    || (center.lat !== this.center.lat || center.lng !== this.center.lng)) {\n                    this.center = center;\n                    LeafletUtil.handleEvent(this.zone, this.centerChange, center);\n                }\n            }\n        };\n        registerEventHandler('moveend', outputUpdateHandler);\n        registerEventHandler('zoomend', outputUpdateHandler);\n    }\n    /**\n     * Resize the map to fit it's parent container\n     */\n    doResize() {\n        // Run this outside of angular so the map events stay outside of angular\n        this.zone.runOutsideAngular(() => {\n            // Invalidate the map size to trigger it to update itself\n            if (null != this.map) {\n                this.map.invalidateSize({});\n            }\n        });\n    }\n    /**\n     * Manage a delayed resize of the component\n     */\n    delayResize() {\n        if (null != this.resizeTimer) {\n            clearTimeout(this.resizeTimer);\n        }\n        this.resizeTimer = setTimeout(this.doResize.bind(this), 200);\n    }\n    /**\n     * Set the view (center/zoom) all at once\n     * @param center The new center\n     * @param zoom The new zoom level\n     */\n    setView(center, zoom) {\n        if (null != this.map && null != center && null != zoom) {\n            this.map.setView(center, zoom, this.zoomPanOptions);\n        }\n    }\n    /**\n     * Set the map zoom level\n     * @param zoom the new zoom level for the map\n     */\n    setZoom(zoom) {\n        if (null != this.map && null != zoom) {\n            this.map.setZoom(zoom, this.zoomOptions);\n        }\n    }\n    /**\n     * Set the center of the map\n     * @param center the center point\n     */\n    setCenter(center) {\n        if (null != this.map && null != center) {\n            this.map.panTo(center, this.panOptions);\n        }\n    }\n    /**\n     * Fit the map to the bounds\n     * @param latLngBounds the boundary to set\n     */\n    setFitBounds(latLngBounds) {\n        if (null != this.map && null != latLngBounds) {\n            this.map.fitBounds(latLngBounds, this.fitBoundsOptions);\n        }\n    }\n    /**\n     * Set the map's max bounds\n     * @param latLngBounds the boundary to set\n     */\n    setMaxBounds(latLngBounds) {\n        if (null != this.map && null != latLngBounds) {\n            this.map.setMaxBounds(latLngBounds);\n        }\n    }\n    /**\n     * Set the map's min zoom\n     * @param number the new min zoom\n     */\n    setMinZoom(zoom) {\n        if (null != this.map && null != zoom) {\n            this.map.setMinZoom(zoom);\n        }\n    }\n    /**\n     * Set the map's min zoom\n     * @param number the new min zoom\n     */\n    setMaxZoom(zoom) {\n        if (null != this.map && null != zoom) {\n            this.map.setMaxZoom(zoom);\n        }\n    }\n}\nLeafletDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.3\", ngImport: i0, type: LeafletDirective, deps: [{ token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });\nLeafletDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.2.3\", type: LeafletDirective, selector: \"[leaflet]\", inputs: { fitBoundsOptions: [\"leafletFitBoundsOptions\", \"fitBoundsOptions\"], panOptions: [\"leafletPanOptions\", \"panOptions\"], zoomOptions: [\"leafletZoomOptions\", \"zoomOptions\"], zoomPanOptions: [\"leafletZoomPanOptions\", \"zoomPanOptions\"], options: [\"leafletOptions\", \"options\"], zoom: [\"leafletZoom\", \"zoom\"], center: [\"leafletCenter\", \"center\"], fitBounds: [\"leafletFitBounds\", \"fitBounds\"], maxBounds: [\"leafletMaxBounds\", \"maxBounds\"], minZoom: [\"leafletMinZoom\", \"minZoom\"], maxZoom: [\"leafletMaxZoom\", \"maxZoom\"] }, outputs: { mapReady: \"leafletMapReady\", zoomChange: \"leafletZoomChange\", centerChange: \"leafletCenterChange\", onClick: \"leafletClick\", onDoubleClick: \"leafletDoubleClick\", onMouseDown: \"leafletMouseDown\", onMouseUp: \"leafletMouseUp\", onMouseMove: \"leafletMouseMove\", onMouseOver: \"leafletMouseOver\", onMouseOut: \"leafletMouseOut\", onMapMove: \"leafletMapMove\", onMapMoveStart: \"leafletMapMoveStart\", onMapMoveEnd: \"leafletMapMoveEnd\", onMapZoom: \"leafletMapZoom\", onMapZoomStart: \"leafletMapZoomStart\", onMapZoomEnd: \"leafletMapZoomEnd\" }, host: { listeners: { \"window:resize\": \"onResize()\" } }, usesOnChanges: true, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.3\", ngImport: i0, type: LeafletDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[leaflet]'\n                }]\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.NgZone }]; }, propDecorators: { fitBoundsOptions: [{\n                type: Input,\n                args: ['leafletFitBoundsOptions']\n            }], panOptions: [{\n                type: Input,\n                args: ['leafletPanOptions']\n            }], zoomOptions: [{\n                type: Input,\n                args: ['leafletZoomOptions']\n            }], zoomPanOptions: [{\n                type: Input,\n                args: ['leafletZoomPanOptions']\n            }], options: [{\n                type: Input,\n                args: ['leafletOptions']\n            }], mapReady: [{\n                type: Output,\n                args: ['leafletMapReady']\n            }], zoom: [{\n                type: Input,\n                args: ['leafletZoom']\n            }], zoomChange: [{\n                type: Output,\n                args: ['leafletZoomChange']\n            }], center: [{\n                type: Input,\n                args: ['leafletCenter']\n            }], centerChange: [{\n                type: Output,\n                args: ['leafletCenterChange']\n            }], fitBounds: [{\n                type: Input,\n                args: ['leafletFitBounds']\n            }], maxBounds: [{\n                type: Input,\n                args: ['leafletMaxBounds']\n            }], minZoom: [{\n                type: Input,\n                args: ['leafletMinZoom']\n            }], maxZoom: [{\n                type: Input,\n                args: ['leafletMaxZoom']\n            }], onClick: [{\n                type: Output,\n                args: ['leafletClick']\n            }], onDoubleClick: [{\n                type: Output,\n                args: ['leafletDoubleClick']\n            }], onMouseDown: [{\n                type: Output,\n                args: ['leafletMouseDown']\n            }], onMouseUp: [{\n                type: Output,\n                args: ['leafletMouseUp']\n            }], onMouseMove: [{\n                type: Output,\n                args: ['leafletMouseMove']\n            }], onMouseOver: [{\n                type: Output,\n                args: ['leafletMouseOver']\n            }], onMouseOut: [{\n                type: Output,\n                args: ['leafletMouseOut']\n            }], onMapMove: [{\n                type: Output,\n                args: ['leafletMapMove']\n            }], onMapMoveStart: [{\n                type: Output,\n                args: ['leafletMapMoveStart']\n            }], onMapMoveEnd: [{\n                type: Output,\n                args: ['leafletMapMoveEnd']\n            }], onMapZoom: [{\n                type: Output,\n                args: ['leafletMapZoom']\n            }], onMapZoomStart: [{\n                type: Output,\n                args: ['leafletMapZoomStart']\n            }], onMapZoomEnd: [{\n                type: Output,\n                args: ['leafletMapZoomEnd']\n            }], onResize: [{\n                type: HostListener,\n                args: ['window:resize', []]\n            }] } });\n\nclass LeafletDirectiveWrapper {\n    constructor(leafletDirective) {\n        this.leafletDirective = leafletDirective;\n    }\n    init() {\n        // Nothing for now\n    }\n    getMap() {\n        return this.leafletDirective.getMap();\n    }\n}\n\n/**\n * Layer directive\n *\n * This directive is used to directly control a single map layer. The purpose of this directive is to\n * be used as part of a child structural directive of the map element.\n *\n */\nclass LeafletLayerDirective {\n    constructor(leafletDirective, zone) {\n        this.zone = zone;\n        // Layer Events\n        this.onAdd = new EventEmitter();\n        this.onRemove = new EventEmitter();\n        this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n    }\n    ngOnInit() {\n        // Init the map\n        this.leafletDirective.init();\n    }\n    ngOnDestroy() {\n        if (null != this.layer) {\n            // Unregister the event handlers\n            this.removeLayerEventListeners(this.layer);\n            // Remove the layer from the map\n            this.layer.remove();\n        }\n    }\n    ngOnChanges(changes) {\n        if (changes['layer']) {\n            // Update the layer\n            const p = changes['layer'].previousValue;\n            const n = changes['layer'].currentValue;\n            this.zone.runOutsideAngular(() => {\n                if (null != p) {\n                    this.removeLayerEventListeners(p);\n                    p.remove();\n                }\n                if (null != n) {\n                    this.addLayerEventListeners(n);\n                    this.leafletDirective.getMap().addLayer(n);\n                }\n            });\n        }\n    }\n    addLayerEventListeners(l) {\n        this.onAddLayerHandler = (e) => LeafletUtil.handleEvent(this.zone, this.onAdd, e);\n        l.on('add', this.onAddLayerHandler);\n        this.onRemoveLayerHandler = (e) => LeafletUtil.handleEvent(this.zone, this.onRemove, e);\n        l.on('remove', this.onRemoveLayerHandler);\n    }\n    removeLayerEventListeners(l) {\n        l.off('add', this.onAddLayerHandler);\n        l.off('remove', this.onRemoveLayerHandler);\n    }\n}\nLeafletLayerDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.3\", ngImport: i0, type: LeafletLayerDirective, deps: [{ token: LeafletDirective }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });\nLeafletLayerDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.2.3\", type: LeafletLayerDirective, selector: \"[leafletLayer]\", inputs: { layer: [\"leafletLayer\", \"layer\"] }, outputs: { onAdd: \"leafletLayerAdd\", onRemove: \"leafletLayerRemove\" }, usesOnChanges: true, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.3\", ngImport: i0, type: LeafletLayerDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[leafletLayer]'\n                }]\n        }], ctorParameters: function () { return [{ type: LeafletDirective }, { type: i0.NgZone }]; }, propDecorators: { layer: [{\n                type: Input,\n                args: ['leafletLayer']\n            }], onAdd: [{\n                type: Output,\n                args: ['leafletLayerAdd']\n            }], onRemove: [{\n                type: Output,\n                args: ['leafletLayerRemove']\n            }] } });\n\n/**\n * Layers directive\n *\n * This directive is used to directly control map layers. As changes are made to the input array of\n * layers, the map is synched to the array. As layers are added or removed from the input array, they\n * are also added or removed from the map. The input array is treated as immutable. To detect changes,\n * you must change the array instance.\n *\n * Important Note: The input layers array is assumed to be immutable. This means you need to use an\n * immutable array implementation or create a new copy of your array when you make changes, otherwise\n * this directive won't detect the change. This is by design. It's for performance reasons. Change\n * detection of mutable arrays requires diffing the state of the array on every DoCheck cycle, which\n * is extremely expensive from a time complexity perspective.\n *\n */\nclass LeafletLayersDirective {\n    constructor(leafletDirective, differs, zone) {\n        this.differs = differs;\n        this.zone = zone;\n        this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n        this.layersDiffer = this.differs.find([]).create();\n    }\n    // Set/get the layers\n    set layers(v) {\n        this.layersValue = v;\n        // Now that we have a differ, do an immediate layer update\n        this.updateLayers();\n    }\n    get layers() {\n        return this.layersValue;\n    }\n    ngDoCheck() {\n        this.updateLayers();\n    }\n    ngOnInit() {\n        // Init the map\n        this.leafletDirective.init();\n        // Update layers once the map is ready\n        this.updateLayers();\n    }\n    ngOnDestroy() {\n        this.layers = [];\n    }\n    /**\n     * Update the state of the layers.\n     * We use an iterable differ to synchronize the map layers with the state of the bound layers array.\n     * This is important because it allows us to react to changes to the contents of the array as well\n     * as changes to the actual array instance.\n     */\n    updateLayers() {\n        const map = this.leafletDirective.getMap();\n        if (null != map && null != this.layersDiffer) {\n            const changes = this.layersDiffer.diff(this.layersValue);\n            if (null != changes) {\n                // Run outside angular to ensure layer events don't trigger change detection\n                this.zone.runOutsideAngular(() => {\n                    changes.forEachRemovedItem((c) => {\n                        map.removeLayer(c.item);\n                    });\n                    changes.forEachAddedItem((c) => {\n                        map.addLayer(c.item);\n                    });\n                });\n            }\n        }\n    }\n}\nLeafletLayersDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.3\", ngImport: i0, type: LeafletLayersDirective, deps: [{ token: LeafletDirective }, { token: i0.IterableDiffers }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });\nLeafletLayersDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.2.3\", type: LeafletLayersDirective, selector: \"[leafletLayers]\", inputs: { layers: [\"leafletLayers\", \"layers\"] }, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.3\", ngImport: i0, type: LeafletLayersDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[leafletLayers]'\n                }]\n        }], ctorParameters: function () { return [{ type: LeafletDirective }, { type: i0.IterableDiffers }, { type: i0.NgZone }]; }, propDecorators: { layers: [{\n                type: Input,\n                args: ['leafletLayers']\n            }] } });\n\nclass LeafletControlLayersChanges {\n    constructor() {\n        this.layersRemoved = 0;\n        this.layersChanged = 0;\n        this.layersAdded = 0;\n    }\n    changed() {\n        return !(this.layersRemoved === 0 && this.layersChanged === 0 && this.layersAdded === 0);\n    }\n}\n\nclass LeafletControlLayersWrapper {\n    constructor(zone, layersControlReady) {\n        this.zone = zone;\n        this.layersControlReady = layersControlReady;\n    }\n    getLayersControl() {\n        return this.layersControl;\n    }\n    init(controlConfig, controlOptions) {\n        const baseLayers = controlConfig.baseLayers || {};\n        const overlays = controlConfig.overlays || {};\n        // Create the control outside of angular to ensure events don't trigger change detection\n        this.zone.runOutsideAngular(() => {\n            this.layersControl = control.layers(baseLayers, overlays, controlOptions);\n        });\n        this.layersControlReady.emit(this.layersControl);\n        return this.layersControl;\n    }\n    applyBaseLayerChanges(changes) {\n        let results = new LeafletControlLayersChanges();\n        if (null != this.layersControl) {\n            results = this.applyChanges(changes, this.layersControl.addBaseLayer);\n        }\n        return results;\n    }\n    applyOverlayChanges(changes) {\n        let results = new LeafletControlLayersChanges();\n        if (null != this.layersControl) {\n            results = this.applyChanges(changes, this.layersControl.addOverlay);\n        }\n        return results;\n    }\n    applyChanges(changes, addFn) {\n        const results = new LeafletControlLayersChanges();\n        if (null != changes) {\n            // All layer management is outside angular to avoid layer events from triggering change detection\n            this.zone.runOutsideAngular(() => {\n                changes.forEachChangedItem((c) => {\n                    this.layersControl.removeLayer(c.previousValue);\n                    addFn.call(this.layersControl, c.currentValue, c.key);\n                    results.layersChanged++;\n                });\n                changes.forEachRemovedItem((c) => {\n                    this.layersControl.removeLayer(c.previousValue);\n                    results.layersRemoved++;\n                });\n                changes.forEachAddedItem((c) => {\n                    addFn.call(this.layersControl, c.currentValue, c.key);\n                    results.layersAdded++;\n                });\n            });\n        }\n        return results;\n    }\n}\n\nclass LeafletControlLayersConfig {\n    constructor() {\n        this.baseLayers = {};\n        this.overlays = {};\n    }\n}\n\n/**\n * Layers Control\n *\n * This directive is used to configure the layers control. The input accepts an object with two\n * key-value maps of layer name -> layer. Mutable changes are detected. On changes, a differ is\n * used to determine what changed so that layers are appropriately added or removed.\n *\n * To specify which layer to show as the 'active' baselayer, you will want to add it to the map\n * using the layers directive. Otherwise, the last one it sees will be used.\n */\nclass LeafletLayersControlDirective {\n    constructor(leafletDirective, differs, zone) {\n        this.differs = differs;\n        this.zone = zone;\n        this.layersControlReady = new EventEmitter();\n        this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n        this.controlLayers = new LeafletControlLayersWrapper(this.zone, this.layersControlReady);\n        // Generate differs\n        this.baseLayersDiffer = this.differs.find({}).create();\n        this.overlaysDiffer = this.differs.find({}).create();\n    }\n    set layersControlConfig(v) {\n        // Validation/init stuff\n        if (null == v) {\n            v = new LeafletControlLayersConfig();\n        }\n        if (null == v.baseLayers) {\n            v.baseLayers = {};\n        }\n        if (null == v.overlays) {\n            v.overlays = {};\n        }\n        // Store the value\n        this.layersControlConfigValue = v;\n        // Update the map\n        this.updateLayers();\n    }\n    get layersControlConfig() {\n        return this.layersControlConfigValue;\n    }\n    ngOnInit() {\n        // Init the map\n        this.leafletDirective.init();\n        // Set up control outside of angular to avoid change detection when using the control\n        this.zone.runOutsideAngular(() => {\n            // Set up all the initial settings\n            this.controlLayers\n                .init({}, this.layersControlOptions)\n                .addTo(this.leafletDirective.getMap());\n        });\n        this.updateLayers();\n    }\n    ngOnDestroy() {\n        this.layersControlConfig = { baseLayers: {}, overlays: {} };\n        this.controlLayers.getLayersControl().remove();\n    }\n    ngDoCheck() {\n        this.updateLayers();\n    }\n    updateLayers() {\n        const map = this.leafletDirective.getMap();\n        const layersControl = this.controlLayers.getLayersControl();\n        if (null != map && null != layersControl) {\n            // Run the baselayers differ\n            if (null != this.baseLayersDiffer && null != this.layersControlConfigValue.baseLayers) {\n                const changes = this.baseLayersDiffer.diff(this.layersControlConfigValue.baseLayers);\n                this.controlLayers.applyBaseLayerChanges(changes);\n            }\n            // Run the overlays differ\n            if (null != this.overlaysDiffer && null != this.layersControlConfigValue.overlays) {\n                const changes = this.overlaysDiffer.diff(this.layersControlConfigValue.overlays);\n                this.controlLayers.applyOverlayChanges(changes);\n            }\n        }\n    }\n}\nLeafletLayersControlDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.3\", ngImport: i0, type: LeafletLayersControlDirective, deps: [{ token: LeafletDirective }, { token: i0.KeyValueDiffers }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });\nLeafletLayersControlDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.2.3\", type: LeafletLayersControlDirective, selector: \"[leafletLayersControl]\", inputs: { layersControlConfig: [\"leafletLayersControl\", \"layersControlConfig\"], layersControlOptions: [\"leafletLayersControlOptions\", \"layersControlOptions\"] }, outputs: { layersControlReady: \"leafletLayersControlReady\" }, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.3\", ngImport: i0, type: LeafletLayersControlDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[leafletLayersControl]'\n                }]\n        }], ctorParameters: function () { return [{ type: LeafletDirective }, { type: i0.KeyValueDiffers }, { type: i0.NgZone }]; }, propDecorators: { layersControlConfig: [{\n                type: Input,\n                args: ['leafletLayersControl']\n            }], layersControlOptions: [{\n                type: Input,\n                args: ['leafletLayersControlOptions']\n            }], layersControlReady: [{\n                type: Output,\n                args: ['leafletLayersControlReady']\n            }] } });\n\n/**\n * Baselayers directive\n *\n * This directive is provided as a convenient way to add baselayers to the map. The input accepts\n * a key-value map of layer name -> layer. Mutable changed are detected. On changes, a differ is\n * used to determine what changed so that layers are appropriately added or removed. This directive\n * will also add the layers control so users can switch between available base layers.\n *\n * To specify which layer to show as the 'active' baselayer, you will want to add it to the map\n * using the layers directive. Otherwise, the plugin will use the last one it sees.\n */\nclass LeafletBaseLayersDirective {\n    constructor(leafletDirective, differs, zone) {\n        this.differs = differs;\n        this.zone = zone;\n        // Output for once the layers control is ready\n        this.layersControlReady = new EventEmitter();\n        this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n        this.controlLayers = new LeafletControlLayersWrapper(this.zone, this.layersControlReady);\n        this.baseLayersDiffer = this.differs.find({}).create();\n    }\n    // Set/get baseLayers\n    set baseLayers(v) {\n        this.baseLayersValue = v;\n        this.updateBaseLayers();\n    }\n    get baseLayers() {\n        return this.baseLayersValue;\n    }\n    ngOnDestroy() {\n        this.baseLayers = {};\n        if (null != this.controlLayers.getLayersControl()) {\n            this.controlLayers.getLayersControl().remove();\n        }\n    }\n    ngOnInit() {\n        // Init the map\n        this.leafletDirective.init();\n        // Create the control outside angular to prevent events from triggering chnage detection\n        this.zone.runOutsideAngular(() => {\n            // Initially configure the controlLayers\n            this.controlLayers\n                .init({}, this.layersControlOptions)\n                .addTo(this.leafletDirective.getMap());\n        });\n        this.updateBaseLayers();\n    }\n    ngDoCheck() {\n        this.updateBaseLayers();\n    }\n    updateBaseLayers() {\n        const map = this.leafletDirective.getMap();\n        const layersControl = this.controlLayers.getLayersControl();\n        if (null != map && null != layersControl && null != this.baseLayersDiffer) {\n            const changes = this.baseLayersDiffer.diff(this.baseLayersValue);\n            const results = this.controlLayers.applyBaseLayerChanges(changes);\n            if (results.changed()) {\n                this.syncBaseLayer();\n            }\n        }\n    }\n    /**\n     * Check the current base layer and change it to the new one if necessary\n     */\n    syncBaseLayer() {\n        const map = this.leafletDirective.getMap();\n        const layers = LeafletUtil.mapToArray(this.baseLayers);\n        let foundLayer;\n        // Search all the layers in the map to see if we can find them in the baselayer array\n        map.eachLayer((l) => {\n            foundLayer = layers.find((bl) => (l === bl));\n        });\n        // Did we find the layer?\n        if (null != foundLayer) {\n            // Yes - set the baselayer to the one we found\n            this.baseLayer = foundLayer;\n        }\n        else {\n            // No - set the baselayer to the first in the array and add it to the map\n            if (layers.length > 0) {\n                this.baseLayer = layers[0];\n                // Add layers outside of angular to prevent events from triggering change detection\n                this.zone.runOutsideAngular(() => {\n                    this.baseLayer.addTo(map);\n                });\n            }\n        }\n    }\n}\nLeafletBaseLayersDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.3\", ngImport: i0, type: LeafletBaseLayersDirective, deps: [{ token: LeafletDirective }, { token: i0.KeyValueDiffers }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });\nLeafletBaseLayersDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.2.3\", type: LeafletBaseLayersDirective, selector: \"[leafletBaseLayers]\", inputs: { baseLayers: [\"leafletBaseLayers\", \"baseLayers\"], layersControlOptions: [\"leafletLayersControlOptions\", \"layersControlOptions\"] }, outputs: { layersControlReady: \"leafletLayersControlReady\" }, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.3\", ngImport: i0, type: LeafletBaseLayersDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[leafletBaseLayers]'\n                }]\n        }], ctorParameters: function () { return [{ type: LeafletDirective }, { type: i0.KeyValueDiffers }, { type: i0.NgZone }]; }, propDecorators: { baseLayers: [{\n                type: Input,\n                args: ['leafletBaseLayers']\n            }], layersControlOptions: [{\n                type: Input,\n                args: ['leafletLayersControlOptions']\n            }], layersControlReady: [{\n                type: Output,\n                args: ['leafletLayersControlReady']\n            }] } });\n\nclass LeafletModule {\n}\nLeafletModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.3\", ngImport: i0, type: LeafletModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nLeafletModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.2.3\", ngImport: i0, type: LeafletModule, declarations: [LeafletDirective,\n        LeafletLayerDirective,\n        LeafletLayersDirective,\n        LeafletLayersControlDirective,\n        LeafletBaseLayersDirective], exports: [LeafletDirective,\n        LeafletLayerDirective,\n        LeafletLayersDirective,\n        LeafletLayersControlDirective,\n        LeafletBaseLayersDirective] });\nLeafletModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.2.3\", ngImport: i0, type: LeafletModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.3\", ngImport: i0, type: LeafletModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    exports: [\n                        LeafletDirective,\n                        LeafletLayerDirective,\n                        LeafletLayersDirective,\n                        LeafletLayersControlDirective,\n                        LeafletBaseLayersDirective\n                    ],\n                    declarations: [\n                        LeafletDirective,\n                        LeafletLayerDirective,\n                        LeafletLayersDirective,\n                        LeafletLayersControlDirective,\n                        LeafletBaseLayersDirective\n                    ]\n                }]\n        }] });\n\nclass LeafletTileLayerDefinition {\n    constructor(type, url, options) {\n        this.type = type;\n        this.url = url;\n        this.options = options;\n    }\n    /**\n     * Creates a TileLayer from the provided definition. This is a convenience function\n     * to help with generating layers from objects.\n     *\n     * @param layerDef The layer to create\n     * @returns {TileLayer} The TileLayer that has been created\n     */\n    static createTileLayer(layerDef) {\n        let layer;\n        switch (layerDef.type) {\n            case 'xyz':\n                layer = tileLayer(layerDef.url, layerDef.options);\n                break;\n            case 'wms':\n            default:\n                layer = tileLayer.wms(layerDef.url, layerDef.options);\n                break;\n        }\n        return layer;\n    }\n    /**\n     * Creates a TileLayer for each key in the incoming map. This is a convenience function\n     * for generating an associative array of layers from an associative array of objects\n     *\n     * @param layerDefs A map of key to tile layer definition\n     * @returns {{[p: string]: TileLayer}} A new map of key to TileLayer\n     */\n    static createTileLayers(layerDefs) {\n        const layers = {};\n        for (const k in layerDefs) {\n            if (layerDefs.hasOwnProperty(k)) {\n                layers[k] = (LeafletTileLayerDefinition.createTileLayer(layerDefs[k]));\n            }\n        }\n        return layers;\n    }\n    /**\n     * Create a Tile Layer from the current state of this object\n     *\n     * @returns {TileLayer} A new TileLayer\n     */\n    createTileLayer() {\n        return LeafletTileLayerDefinition.createTileLayer(this);\n    }\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { LeafletBaseLayersDirective, LeafletControlLayersChanges, LeafletControlLayersConfig, LeafletControlLayersWrapper, LeafletDirective, LeafletDirectiveWrapper, LeafletLayerDirective, LeafletLayersControlDirective, LeafletLayersDirective, LeafletModule, LeafletTileLayerDefinition, LeafletUtil };\n"]},"metadata":{},"sourceType":"module"}